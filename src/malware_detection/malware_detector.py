import os
import hashlib
import yara
import logging
import tempfile
from pathlib import Path
from typing import Dict, List, Tuple, Any, Optional

logger = logging.getLogger(__name__)

class MalwareDetector:
    def __init__(self, yara_rules_dir: str = "src/malware_detection/yara_rules"):
        """
        Initialize the malware detector with YARA rules.
        
        Args:
            yara_rules_dir: Directory containing YARA rule files
        """
        self.yara_rules_dir = Path(yara_rules_dir)
        self.rules = None
        
        # Create temp directory for scanning memory files
        self.temp_dir = Path("src/malware_detection/temp")
        os.makedirs(self.temp_dir, exist_ok=True)
        
        self.load_rules()
    
    def load_rules(self) -> None:
        """Load all YARA rules from the rules directory."""
        try:
            filepaths = {}
            for file in self.yara_rules_dir.glob("*.yar"):
                filepaths[file.stem] = str(file)
            
            if filepaths:
                self.rules = yara.compile(filepaths=filepaths)
                logger.info(f"Loaded YARA rules from {len(filepaths)} files")
            else:
                logger.warning(f"No YARA rule files found in {self.yara_rules_dir}")
        except Exception as e:
            logger.error(f"Error loading YARA rules: {e}")
            self.rules = None
    
    def scan_file(self, file_path: str) -> Dict[str, Any]:
        """
        Scan a file for malware using YARA rules.
        
        Args:
            file_path: Path to the file to scan
            
        Returns:
            Dict containing scan results
        """
        result = {
            "file_path": file_path,
            "file_name": os.path.basename(file_path),
            "file_size": os.path.getsize(file_path),
            "md5": self._get_file_hash(file_path, "md5"),
            "sha1": self._get_file_hash(file_path, "sha1"),
            "sha256": self._get_file_hash(file_path, "sha256"),
            "detections": [],
            "is_malicious": False,
            "error": None
        }
        
        try:
            if not self.rules:
                result["error"] = "No YARA rules loaded"
                return result
                
            matches = self.rules.match(file_path)
            
            if matches:
                result["is_malicious"] = True
                for match in matches:
                    detection = {
                        "rule_name": match.rule,
                        "tags": match.tags,
                        "strings": [],
                        "meta": match.meta
                    }
                    
                    # Extract matched strings
                    for string_id, instances in match.strings.items():
                        for instance in instances:
                            offset, identifier, string_data = instance
                            
                            # Try to decode binary data if possible, otherwise use hex
                            try:
                                if isinstance(string_data, bytes):
                                    string_value = string_data.decode('utf-8', errors='replace')
                                else:
                                    string_value = str(string_data)
                            except:
                                string_value = string_data.hex()
                                
                            detection["strings"].append({
                                "offset": offset,
                                "identifier": identifier,
                                "value": string_value[:100]  # Limit string length
                            })
                    
                    result["detections"].append(detection)
            
        except Exception as e:
            result["error"] = str(e)
            logger.error(f"Error scanning file {file_path}: {e}")
            
        return result
    
    def _get_file_hash(self, file_path: str, algorithm: str = "sha256") -> str:
        """
        Calculate the hash of a file.
        
        Args:
            file_path: Path to the file
            algorithm: Hash algorithm to use (md5, sha1, sha256)
            
        Returns:
            Hex digest of the file hash
        """
        hash_alg = hashlib.new(algorithm)
        
        try:
            with open(file_path, "rb") as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    hash_alg.update(chunk)
            return hash_alg.hexdigest()
        except Exception as e:
            logger.error(f"Error calculating {algorithm} hash for {file_path}: {e}")
            return ""
    
    def scan_memory_file(self, file_data: bytes, filename: str = "memory_file") -> Dict[str, Any]:
        """
        Scan a file from memory.
        
        Args:
            file_data: File content as bytes
            filename: Optional filename for reporting
            
        Returns:
            Dict containing scan results
        """
        try:
            # Ensure temp directory exists
            os.makedirs(self.temp_dir, exist_ok=True)
            
            with tempfile.NamedTemporaryFile(delete=False, dir=str(self.temp_dir)) as temp_file:
                temp_file.write(file_data)
                temp_path = temp_file.name
            
            result = self.scan_file(temp_path)
            result["file_name"] = filename
            
            # Clean up
            try:
                os.unlink(temp_path)
            except:
                pass
                
            return result
            
        except Exception as e:
            logger.error(f"Error scanning memory file: {e}")
            return {
                "file_name": filename,
                "file_size": len(file_data),
                "detections": [],
                "is_malicious": False,
                "error": str(e)
            } 