import os
import re
import hashlib
import magic
import math
import binascii
import logging
import yara
import shutil
import tempfile
from collections import Counter
from pathlib import Path

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('malware_detector')

# Paths
YARA_RULES_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'yara_rules')
TEMP_DIR = os.path.join(tempfile.gettempdir(), 'malware_analysis')

# Create directories if they don't exist
os.makedirs(YARA_RULES_DIR, exist_ok=True)
os.makedirs(TEMP_DIR, exist_ok=True)

# Initialize YARA rules
yara_rules = None

def load_yara_rules():
    """Load all YARA rules from the rules directory."""
    global yara_rules
    
    try:
        filepaths = {}
        rule_count = 0
        
        # Load each .yar file in the YARA rules directory
        for file in os.listdir(YARA_RULES_DIR):
            if file.endswith('.yar') or file.endswith('.yara'):
                rule_path = os.path.join(YARA_RULES_DIR, file)
                filepaths[file] = rule_path
                rule_count += 1
        
        if rule_count > 0:
            # Compile all rules
            yara_rules = yara.compile(filepaths=filepaths)
            logger.info(f"Loaded {rule_count} YARA rules")
            return True
        else:
            logger.warning("No YARA rules found to load")
            return False
    except Exception as e:
        logger.error(f"Error loading YARA rules: {str(e)}")
        return False

# Load rules on module import
load_yara_rules()

def save_yara_rule(rule_name, rule_content):
    """Save a new YARA rule to the rules directory."""
    if not rule_name.endswith('.yar'):
        rule_name = f"{rule_name}.yar"
    
    rule_path = os.path.join(YARA_RULES_DIR, rule_name)
    
    try:
        with open(rule_path, 'w') as f:
            f.write(rule_content)
        
        # Reload rules after adding a new one
        load_yara_rules()
        
        return True, "YARA rule added successfully"
    except Exception as e:
        logger.error(f"Error saving YARA rule: {str(e)}")
        return False, f"Error saving YARA rule: {str(e)}"

def calculate_file_hashes(file_path):
    """Calculate MD5, SHA1, and SHA256 hashes for a file."""
    try:
        md5 = hashlib.md5()
        sha1 = hashlib.sha1()
        sha256 = hashlib.sha256()
        
        with open(file_path, 'rb') as f:
            # Read the file in chunks to handle large files
            for chunk in iter(lambda: f.read(4096), b''):
                md5.update(chunk)
                sha1.update(chunk)
                sha256.update(chunk)
        
        return {
            'md5': md5.hexdigest(),
            'sha1': sha1.hexdigest(),
            'sha256': sha256.hexdigest()
        }
    except Exception as e:
        logger.error(f"Error calculating file hashes: {str(e)}")
        return None

def calculate_entropy(data):
    """Calculate Shannon entropy of data."""
    if not data:
        return 0
    
    entropy = 0
    for x in range(256):
        p_x = data.count(bytes([x])) / len(data)
        if p_x > 0:
            entropy += -p_x * math.log(p_x, 2)
    
    return entropy

def extract_strings(file_path, min_length=4):
    """Extract ASCII and Unicode strings from a binary file."""
    try:
        ascii_strings = []
        unicode_strings = []
        
        with open(file_path, 'rb') as f:
            data = f.read()
        
        # Extract ASCII strings
        ascii_pattern = re.compile(b'[\x20-\x7E]{' + str(min_length).encode() + b',}')
        ascii_strings = [match.group().decode('ascii') for match in ascii_pattern.finditer(data)]
        
        # Extract Unicode strings (UTF-16LE)
        unicode_pattern = re.compile(b'(?:[\x20-\x7E]\x00){' + str(min_length).encode() + b',}')
        unicode_matches = [match.group() for match in unicode_pattern.finditer(data)]
        for match in unicode_matches:
            try:
                unicode_strings.append(match.decode('utf-16le'))
            except UnicodeDecodeError:
                pass
        
        return ascii_strings, unicode_strings
    except Exception as e:
        logger.error(f"Error extracting strings: {str(e)}")
        return [], []

def check_suspicious_strings(strings):
    """Check for suspicious strings that might indicate malware."""
    suspicious_patterns = [
        r'(?i)CreateRemoteThread',
        r'(?i)VirtualAlloc',
        r'(?i)WriteProcessMemory',
        r'(?i)ShellExecute',
        r'(?i)cmd\.exe',
        r'(?i)powershell',
        r'(?i)WScript\.Shell',
        r'(?i)RunDll32',
        r'(?i)RegCreateKey',
        r'(?i)HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run',
        r'(?i)HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run',
        r'(?i)WinExec',
        r'(?i)URLDownloadToFile',
        r'(?i)GetProcAddress',
        r'(?i)LoadLibrary',
        r'(?i)GetAsyncKeyState',
        r'(?i)GetForegroundWindow',
        r'(?i)SetWindowsHookEx',
        r'(?i)WH_KEYBOARD',
        r'(?i)WH_KEYBOARD_LL',
        r'(?i)CreateMutex',
        r'(?i)CreateService',
        r'(?i)StartService',
        r'(?i)NtCreateThreadEx',
        r'(?i)CreateProcess',
        r'(?i)AdjustTokenPrivileges',
        r'(?i)LsaEnumerateLogonSessions',
        r'(?i)StrCat',
        r'(?i)strcpy',
        r'(?i)system\(',
        r'(?i)eval\(',
        r'(?i)exec\(',
        r'(?i)execve\(',
        r'(?i)fork\(',
        r'(?i)popen\(',
        r'(?i)base64',
        r'(?i)certutil -decode',
        r'(?i)meterpreter',
        r'(?i)metasploit',
        r'(?i)payload',
        r'(?i)exploit',
        r'(?i)backdoor',
        r'(?i)trojan',
        r'(?i)botnet',
        r'(?i)keylog'
    ]
    
    suspicious = []
    
    for s in strings:
        for pattern in suspicious_patterns:
            if re.search(pattern, s):
                suspicious.append((s, pattern))
                break
    
    return suspicious

def analyze_file(file_path):
    """
    Analyze a file for potential malware.
    
    Returns a dictionary with analysis results.
    """
    try:
        file_name = os.path.basename(file_path)
        
        # Get file information
        file_size = os.path.getsize(file_path)
        file_type = magic.from_file(file_path)
        mime_type = magic.from_file(file_path, mime=True)
        
        # Calculate file hashes
        hashes = calculate_file_hashes(file_path)
        
        # Extract strings
        ascii_strings, unicode_strings = extract_strings(file_path)
        
        # Check for suspicious strings
        suspicious = check_suspicious_strings(ascii_strings + unicode_strings)
        
        # Calculate entropy
        with open(file_path, 'rb') as f:
            data = f.read()
        entropy = calculate_entropy(data)
        
        # Run YARA rules
        yara_matches = []
        if yara_rules:
            matches = yara_rules.match(file_path)
            for match in matches:
                yara_matches.append({
                    'rule': match.rule,
                    'strings': [str(s) for s in match.strings],
                    'tags': match.tags
                })
        
        # Initial threat assessment
        severity = "safe"
        reasons = []
        
        # Check entropy (high entropy can indicate encryption or packing)
        if entropy > 7.0:
            severity = max(severity, "low")
            reasons.append("High entropy (possible encryption or packing)")
        
        # Check suspicious strings
        if suspicious:
            severity = max(severity, "medium")
            reasons.append(f"Contains {len(suspicious)} suspicious API calls or patterns")
        
        # Check YARA matches
        if yara_matches:
            severity = max(severity, "high")
            reasons.append(f"Matched {len(yara_matches)} YARA rules")
        
        # Embedded PE files or shell scripts are highly suspicious
        embedded_files = []
        if b'MZ' in data and data.find(b'MZ') != 0:
            embedded_files.append("Embedded PE file")
            severity = max(severity, "critical")
            reasons.append("Contains embedded PE file")
        
        if mime_type != "application/x-dosexec" and b"#!/bin/sh" in data:
            embedded_files.append("Embedded shell script")
            severity = max(severity, "high")
            reasons.append("Contains embedded shell script")
        
        # Format results
        results = {
            "file_info": {
                "name": file_name,
                "size": f"{file_size} bytes",
                "type": file_type,
                "mime_type": mime_type,
                "md5": hashes["md5"],
                "sha1": hashes["sha1"],
                "sha256": hashes["sha256"],
                "entropy": f"{entropy:.2f}"
            },
            "threat_assessment": {
                "severity": severity,
                "confidence": "medium",
                "reasons": reasons
            },
            "yara_matches": [f"{match['rule']} (tags: {', '.join(match['tags'])})" for match in yara_matches],
            "malware_signatures": [],  # Reserved for future implementation of signature database
            "anomalies": [],
            "suspicious_strings": [f"{s[0]} (matched: {s[1]})" for s in suspicious],
            "embedded_files": embedded_files
        }
        
        logger.info(f"Analysis completed for {file_name}: {severity} threat level")
        return results
        
    except Exception as e:
        logger.error(f"Error analyzing file: {str(e)}")
        raise Exception(f"Analysis failed: {str(e)}")

def get_service_status():
    """Get the status of the malware detection service."""
    return {
        "running": True,
        "version": "1.0.0",
        "yara_rules_loaded": yara_rules is not None
    } 