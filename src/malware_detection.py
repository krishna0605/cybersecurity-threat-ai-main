"""
Malware Detection Module

This module analyzes files for potential malicious content and behaviors
using static analysis techniques.
"""

import os
import re
import math
import hashlib
import binascii
import zipfile
import io
import string
import logging
import numpy as np
from collections import Counter
import magic
import pefile
import yara
import lief
from pathlib import Path
import json
import tempfile
import subprocess
import rarfile
import olefile
from datetime import datetime
from werkzeug.utils import secure_filename

# Known malware hashes (example - in production, this would be a much larger database)
KNOWN_MALWARE_HASHES = {
    "44d88612fea8a8f36de82e1278abb02f": "Eicar Test File",
    "275a021bbfb6489e54d471899f7db9d1": "Example Malware 1",
    "5eb63bbbe01eeed093cb22bb8f5acdc3": "Example Malware 2"
}

# Load YARA rules
YARA_RULES_PATH = os.path.join(os.path.dirname(__file__), 'yara_rules')

def load_yara_rules():
    """Load compiled YARA rules from the rules directory"""
    try:
        if os.path.exists(YARA_RULES_PATH):
            rules = {}
            for rule_file in os.listdir(YARA_RULES_PATH):
                if rule_file.endswith('.yar') or rule_file.endswith('.yara'):
                    rule_path = os.path.join(YARA_RULES_PATH, rule_file)
                    try:
                        rules[rule_file] = yara.compile(rule_path)
                    except Exception as e:
                        print(f"Error compiling YARA rule {rule_file}: {str(e)}")
            return rules
        else:
            # If no rules path exists, use a simple default rule
            default_rule = """
            rule suspicious_strings {
                strings:
                    $cmd1 = "cmd.exe" nocase
                    $ps1 = "powershell" nocase
                    $s1 = "CreateProcess" nocase
                    $s2 = "VirtualAlloc" nocase
                    $s3 = "WriteProcessMemory" nocase
                    $s4 = "CreateRemoteThread" nocase
                    $s5 = "RegSetValue" nocase
                    $s6 = "WScript.Shell" nocase
                    $s7 = "ShellExecute" nocase
                    $s8 = "Downloads\\\\run" nocase
                    $net1 = "InternetOpen" nocase
                    $net2 = "InternetConnect" nocase
                    $net3 = "URLDownloadToFile" nocase
                    $net4 = "WSAStartup" nocase
                condition:
                    2 of them
            }
            """
            return {"default_rules.yar": yara.compile(source=default_rule)}
    except Exception as e:
        print(f"Error loading YARA rules: {str(e)}")
        # Return empty rules if there's an error
        return {}

# Suspicious file extensions
SUSPICIOUS_EXTENSIONS = {
    '.exe': 'Executable file',
    '.dll': 'Dynamic Link Library',
    '.scr': 'Screensaver (potential executable)',
    '.bat': 'Batch file',
    '.cmd': 'Command script',
    '.ps1': 'PowerShell script',
    '.vbs': 'Visual Basic script',
    '.js': 'JavaScript file',
    '.hta': 'HTML Application',
    '.jar': 'Java Archive',
    '.pif': 'Program Information File (potential executable)',
    '.com': 'Command file (executable)',
    '.msi': 'Windows Installer package',
    '.reg': 'Registry file',
    '.vbe': 'VBScript Encoded script',
    '.wsf': 'Windows Script File',
    '.jse': 'JScript Encoded file',
    '.lnk': 'Shortcut file (might point to malicious target)'
}

# Suspicious strings patterns
SUSPICIOUS_PATTERNS = [
    (r'(cmd\.exe|powershell\.exe|wscript\.exe|cscript\.exe|regsvr32\.exe|rundll32\.exe)', 'System command execution'),
    (r'(CreateProcess|ShellExecute|WinExec|system\(|exec\(|eval\(|subprocess)', 'Process creation'),
    (r'(VirtualAlloc|WriteProcessMemory|CreateRemoteThread|LoadLibrary|GetProcAddress)', 'Memory manipulation'),
    (r'(RegCreate|RegSet|RegOpen|CurrentVersion\\Run|HKEY_LOCAL_MACHINE)', 'Registry manipulation'),
    (r'(InternetOpen|InternetConnect|URLDownload|WSAStartup|connect\(|socket\()', 'Network connectivity'),
    (r'(DownloadFile|DownloadString|WebClient|HttpClient|wget|curl)', 'Web downloading'),
    (r'(password|login|credential|account|token|apikey|api_key|secret)', 'Credential handling'),
    (r'(encrypt|decrypt|AES|RSA|RC4|XOR|base64|md5|sha1|sha256)', 'Cryptographic operations'),
    (r'(temp\\|%temp%|%appdata%|%localappdata%|%programdata%)', 'Suspicious file paths'),
    (r'(http://|https://|ftp://)', 'URL in binary or script'),
    (r'(hidden|vbhidden|wscript\.shell|shellexecute|ShowWindow)', 'Window/process hiding'),
]

class MalwareDetector:
    """Class for detecting potential malware in various file types"""
    
    def __init__(self):
        # Initialize YARA rules
        self.yara_rules = load_yara_rules()
    
    def analyze_file(self, file_path, original_filename):
        """
        Analyze a file for malware detection
        Returns a dictionary with analysis results
        """
        results = {
            "file_info": get_file_info(file_path, original_filename),
            "threat_assessment": {
                "severity": "safe",
                "score": 0,
                "description": "No threats detected"
            },
            "yara_matches": [],
            "malware_signatures": detect_malware_signatures(file_path),
            "anomalies": detect_anomalies(file_path, original_filename),
            "suspicious_strings": [],
            "embedded_files": []
        }
        
        # Run YARA scans
        yara_results = scan_with_yara(file_path)
        if yara_results:
            results["yara_matches"] = yara_results
        
        # Extract and analyze strings
        results["suspicious_strings"] = extract_suspicious_strings(file_path)
        
        # Check for embedded files
        embedded = detect_embedded_files(file_path)
        if embedded:
            results["embedded_files"] = embedded
        
        # Calculate overall threat score
        score = calculate_threat_score(results)
        results["threat_assessment"]["score"] = score
        
        # Determine severity based on score
        if score >= 70:
            results["threat_assessment"]["severity"] = "critical"
            results["threat_assessment"]["description"] = "Critical security threat detected"
        elif score >= 50:
            results["threat_assessment"]["severity"] = "high"
            results["threat_assessment"]["description"] = "High risk - potentially malicious"
        elif score >= 30:
            results["threat_assessment"]["severity"] = "medium"
            results["threat_assessment"]["description"] = "Medium risk - suspicious behaviors detected"
        elif score >= 10:
            results["threat_assessment"]["severity"] = "low"
            results["threat_assessment"]["description"] = "Low risk - minor suspicious indicators"
        else:
            results["threat_assessment"]["severity"] = "safe"
            results["threat_assessment"]["description"] = "No significant threats detected"
        
        return results
    
    # Add compatibility methods for the API
    def scan_file(self, file_path):
        """
        Compatibility method for the malware_detector API
        Wraps analyze_file with a simpler interface
        """
        try:
            # Get original filename from path
            original_filename = os.path.basename(file_path)
            
            # Run the full analysis
            result = self.analyze_file(file_path, original_filename)
            
            # Adapt to the expected format for the web UI
            simplified_result = {
                "file_path": file_path,
                "file_name": original_filename,
                "file_size": os.path.getsize(file_path),
                "md5": hashlib.md5(open(file_path, 'rb').read()).hexdigest(),
                "sha1": hashlib.sha1(open(file_path, 'rb').read()).hexdigest(),
                "sha256": hashlib.sha256(open(file_path, 'rb').read()).hexdigest(),
                "detections": [],
                "is_malicious": result["threat_assessment"]["severity"] != "safe",
                "error": None
            }
            
            # Convert YARA matches to the expected format
            for match in result.get("yara_matches", []):
                detection = {
                    "rule_name": match.get("rule", "Unknown Rule"),
                    "tags": match.get("tags", []),
                    "strings": [],
                    "meta": match.get("meta", {})
                }
                
                # Add string matches
                for string_match in match.get("matches", []):
                    detection["strings"].append({
                        "offset": string_match.get("offset", 0),
                        "identifier": string_match.get("identifier", "unknown"),
                        "value": string_match.get("value", "")[:100]  # Limit string length
                    })
                
                simplified_result["detections"].append(detection)
            
            return simplified_result
        except Exception as e:
            # Log the error
            print(f"Error in scan_file: {str(e)}")
            
            # Return a basic error result
            return {
                "file_path": file_path,
                "file_name": os.path.basename(file_path),
                "file_size": os.path.getsize(file_path) if os.path.exists(file_path) else 0,
                "md5": "",
                "sha1": "",
                "sha256": "",
                "detections": [],
                "is_malicious": False,
                "error": str(e)
            }
    
    def scan_memory_file(self, file_data, filename="memory_file"):
        """
        Compatibility method for scanning file data in memory
        """
        try:
            # Create a temporary file
            temp_dir = tempfile.gettempdir()
            temp_path = os.path.join(temp_dir, secure_filename(filename))
            
            with open(temp_path, 'wb') as f:
                f.write(file_data)
            
            # Scan the temporary file
            result = self.scan_file(temp_path)
            
            # Clean up
            os.unlink(temp_path)
            
            # Update filename in results
            result["file_name"] = filename
            
            return result
        except Exception as e:
            # Log the error
            print(f"Error in scan_memory_file: {str(e)}")
            
            # Return a basic error result
            return {
                "file_name": filename,
                "file_size": len(file_data),
                "detections": [],
                "is_malicious": False,
                "error": str(e)
            }

# Create a global instance for use in the app
malware_detector = MalwareDetector()

# Example usage:
if __name__ == "__main__":
    detector = MalwareDetector()
    
    import sys
    if len(sys.argv) > 1:
        target = sys.argv[1]
        if os.path.isfile(target):
            result = detector.analyze_file(target)
            print(json.dumps(result, indent=4))
        elif os.path.isdir(target):
            result = detector.scan_directory(target)
            print(json.dumps(result, indent=4))
        else:
            print(f"Invalid target: {target}")
    else:
        print("Usage: python malware_detection.py <file_or_directory>")

# Helper functions needed by the MalwareDetector class
def get_file_info(file_path, original_filename):
    """Get basic file information"""
    try:
        file_size = os.path.getsize(file_path)
        file_type = magic.from_file(file_path) if 'magic' in globals() else "Unknown"
        mime_type = magic.from_file(file_path, mime=True) if 'magic' in globals() else "Unknown"
        
        # Get file hashes
        with open(file_path, 'rb') as f:
            data = f.read()
            md5 = hashlib.md5(data).hexdigest()
            sha1 = hashlib.sha1(data).hexdigest()
            sha256 = hashlib.sha256(data).hexdigest()
        
        # Check file extension risk
        _, ext = os.path.splitext(original_filename.lower())
        extension_risk = SUSPICIOUS_EXTENSIONS.get(ext, None)
        
        # Get creation and modification times
        create_time = os.path.getctime(file_path)
        modify_time = os.path.getmtime(file_path)
        
        return {
            "filename": original_filename,
            "size": file_size,
            "size_human": format_size(file_size),
            "file_type": file_type,
            "mime_type": mime_type,
            "extension": ext,
            "extension_risk": extension_risk,
            "hashes": {
                "md5": md5,
                "sha1": sha1,
                "sha256": sha256
            },
            "timestamps": {
                "created": datetime.fromtimestamp(create_time).isoformat(),
                "modified": datetime.fromtimestamp(modify_time).isoformat()
            }
        }
    except Exception as e:
        print(f"Error getting file info: {str(e)}")
        return {
            "filename": original_filename,
            "error": str(e)
        }

def scan_with_yara(file_path):
    """Scan a file with YARA rules"""
    results = []
    
    # Get rules from global scope
    rules = {}
    if 'yara_rules' in globals():
        rules = yara_rules
    
    # If no rules in global scope, try to use the ones from MalwareDetector class
    if not rules and 'malware_detector' in globals() and hasattr(malware_detector, 'yara_rules'):
        rules = malware_detector.yara_rules
    
    if not rules:
        return results
    
    try:
        for rule_name, rule in rules.items():
            matches = rule.match(file_path)
            for match in matches:
                match_info = {
                    "rule": match.rule,
                    "namespace": match.namespace,
                    "tags": match.tags,
                    "meta": match.meta,
                    "matches": []
                }
                
                # Get string matches
                for string_id, string_hits in match.strings.items():
                    for offset, _, string_data in string_hits:
                        # Try to decode binary data to string when possible
                        try:
                            if isinstance(string_data, bytes):
                                string_value = string_data.decode('utf-8', errors='replace')
                            else:
                                string_value = str(string_data)
                        except:
                            string_value = string_data.hex()
                        
                        match_info["matches"].append({
                            "offset": offset,
                            "identifier": string_id,
                            "value": string_value[:100]  # Truncate long strings
                        })
                
                results.append(match_info)
    except Exception as e:
        print(f"Error in YARA scan: {str(e)}")
    
    return results

def detect_malware_signatures(file_path):
    """Check for known malware signatures"""
    signatures = []
    
    try:
        # Calculate MD5 hash
        with open(file_path, 'rb') as f:
            md5 = hashlib.md5(f.read()).hexdigest()
        
        # Check against known malware hashes
        if md5 in KNOWN_MALWARE_HASHES:
            signatures.append({
                "type": "known_hash",
                "value": md5,
                "description": KNOWN_MALWARE_HASHES[md5]
            })
    except Exception as e:
        print(f"Error checking malware signatures: {str(e)}")
    
    return signatures

def detect_anomalies(file_path, original_filename):
    """Detect file anomalies that might indicate malware"""
    anomalies = []
    
    try:
        # Check for suspicious file extension
        _, ext = os.path.splitext(original_filename.lower())
        if ext in SUSPICIOUS_EXTENSIONS:
            anomalies.append({
                "type": "suspicious_extension",
                "extension": ext,
                "description": SUSPICIOUS_EXTENSIONS[ext]
            })
        
        # More anomaly checks can be added here
        
    except Exception as e:
        print(f"Error checking for anomalies: {str(e)}")
    
    return anomalies

def extract_suspicious_strings(file_path):
    """Extract and analyze strings from the file"""
    suspicious = []
    
    try:
        # Read the file as binary
        with open(file_path, 'rb') as f:
            data = f.read()
        
        # Extract ASCII strings (at least 4 chars)
        strings_ascii = re.findall(b'[\x20-\x7E]{4,}', data)
        strings_ascii = [s.decode('ascii') for s in strings_ascii]
        
        # Extract Unicode strings (at least 4 chars)
        strings_unicode = []
        for match in re.finditer(b'(?:[\x20-\x7E]\x00){4,}', data):
            try:
                unicode_str = match.group().decode('utf-16le')
                strings_unicode.append(unicode_str)
            except:
                pass
        
        # Combine all strings
        all_strings = strings_ascii + strings_unicode
        
        # Check for suspicious patterns
        for string in all_strings:
            for pattern, description in SUSPICIOUS_PATTERNS:
                if re.search(pattern, string, re.IGNORECASE):
                    suspicious.append({
                        "string": string,
                        "pattern": pattern,
                        "description": description
                    })
                    break  # Only report the first matching pattern for each string
    
    except Exception as e:
        print(f"Error extracting strings: {str(e)}")
    
    return suspicious

def detect_embedded_files(file_path):
    """Detect embedded files that might be hidden in the main file"""
    embedded = []
    
    # Implementation would depend on the file type
    # This is a placeholder for actual implementation
    
    return embedded

def calculate_threat_score(results):
    """Calculate overall threat score from 0-100"""
    score = 0
    
    # Add points for YARA matches
    yara_matches = results.get("yara_matches", [])
    if yara_matches:
        # Add 10-50 points based on YARA match severity
        for match in yara_matches:
            severity = match.get("meta", {}).get("severity", "medium").lower()
            if severity == "critical":
                score += 50
            elif severity == "high":
                score += 30
            elif severity == "medium":
                score += 20
            elif severity == "low":
                score += 10
    
    # Add points for known malware signatures (max 100)
    if results.get("malware_signatures", []):
        score += 100
    
    # Add points for suspicious strings (max 40)
    suspicious_strings = results.get("suspicious_strings", [])
    if suspicious_strings:
        string_score = min(40, len(suspicious_strings) * 5)
        score += string_score
    
    # Add points for anomalies (max 30)
    anomalies = results.get("anomalies", [])
    if anomalies:
        anomaly_score = min(30, len(anomalies) * 10)
        score += anomaly_score
    
    # Add points for embedded files (max 20)
    embedded_files = results.get("embedded_files", [])
    if embedded_files:
        embedded_score = min(20, len(embedded_files) * 5)
        score += embedded_score
    
    # Cap the score at 100
    return min(100, score)

def format_size(size_bytes):
    """Format file size in human-readable format"""
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if size_bytes < 1024.0 or unit == 'TB':
            return f"{size_bytes:.2f} {unit}"
        size_bytes /= 1024.0 